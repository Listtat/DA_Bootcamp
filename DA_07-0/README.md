# Проект 07

Работа с несколькими источниками данных

## Cодержание

1. [Chapter I](#chapter-i) \
    1.1. [Введение](#введение) 
2. [Chapter II](#chapter-ii) \
    2.1. [Общая инструкция](#общая-инструкция) 
3. [Chapter III](#chapter-iii) \
    3.1. [Знакомство с инструментом](#знакомство-с-инструментом) \
    3.2. [Задание](#задание)\
    3.3. [*Дополнительное задание](#дополнительное-задание)
4. [Chapter IV](#chapter-iv)\
    4.1 [Сдача работы и проверка](#сдача-работы-и-проверка) 


<h2 id="chapter-i">Chapter I</h2> 
<h3 id="введение">Введение</h3>

В этом проекте мы продолжим исследовать поведение пользователей нашего интернет-магазина. Ранее мы базировались только на данных о совершенных покупках (event_type = ‘purchase’). Теперь к покупкам у нас есть еще другие действия, которые можно было совершить: ‘view’ - просмотр страницы, ‘cart’ - переход в корзину.

Напомню, что в проекте 5 мы составляли customer journey map (CJM) нашего покупателя. В проекте 6, руководствуясь основными метриками, мы вычисляли выручку и средний чек. В этом проекте нам предстоит познакомиться с объединением данных из нескольких источников, научиться вычислять конверсии по воронке, MAU, %PU.

При объединении и преобразовании таблиц в начале пути полезно пробовать их визуализировать, рисовать на листике пересечение множеств, как долен выглядеть конечный результат. Затем далее разбивать это на отдельные шаги (в нашем случае это могут быть подзапросы) и пробовать писать код. Важно выработать привычку периодически перепроверять себя через связанные метрики: например, количество пользователей, совершивших покупку, не может быть больше размера месячной аудитории.

На рисунке ниже изображены примеры разных вариантов объединения таблиц. Таблицы объединяются по параметрам, указанными в ON. Это могут быть любые логические выражения: 

- простые: таблица1.ID = таблица2.ID, где в качестве ID могут быть ФИО, номер сессии в приложении, модель телефона и др. параметры
- либо что-то посложнее: даты &lt;> какого-то события (дата первого входа в приложение не может быть раньше, чем дата регистрации и т.д.)

Параметры для объединения должны иметь одинаковый тип данных: строка = строка, число = число и т.д.

<img src="https://lh3.googleusercontent.com/jGtiUtD2SAGcR6LIn6PIrvT1e-yHWZtIA7uPBHSCLJ65ZM1K_S8DTgI_eKmronh0YFWjSLFhOsI1MK9FoIA2DzGnq3gNuQpGW3sdoVAiLf8gVe1EYSaOgp-DjsZ5vzIRkOZATEUuRiQNi2DmIiB3L7Q" width=50% height=50% >

При перечислении конкретных столбцов в запросе и параметров для объединения принято использовать для обозначения таблицы **alias** (алиас) - временное имя. Используя конструкцию table1_very_long_name **AS** t1, мы далее в запросе можем использовать не полное название таблицы, а t1.

Кроме пересечения таблиц по набору условий существует еще один вид их объединения - конструкции **union** и **union all**.

- UNION – это оператор SQL для объединения результирующего набора данных нескольких запросов, и данный оператор выводит только уникальные строки в запросах, т.е. удаляет дубликаты.
- UNION ALL – это оператор SQL для объединения результирующего набора данных нескольких запросов, а вот данный оператор, выведет уже абсолютно все строки, даже дубли.

<img src="https://lh5.googleusercontent.com/m-4vIIJtSrdWbww-YTbuNh4T0rvLn9lLNW8YVi9O-OG9vs0aHeCs03Pkk-y2otPaXbDed2CE6Z_PCsIxLcAiX3FNKRXhVtUTXqQI37BOknNDHxsP8iFTCsAIx5czXpLacXU0fM5CAiI5VV3uMcg2kmY" width=50% height=50% >

Так как все колонки будут как бы ставиться друг на друга, необходимо чтобы и набор полей, и типы данных были одинаковыми. В случае сортировки оператор **order by **можно указать только после последнего запроса.

<h2 id="chapter-ii">Chapter II</h2> 
<h3 id="общая-инструкция">Общая инструкция</h3>

Методология Школы 21 может быть не похожа на тот образовательный опыт, который случался с тобой ранее. Её отличает высокий уровень автономии: у тебя есть задача, ты должен её выполнить. По большей части тебе нужно будет самому добывать знания для её решения. Второй важный момент — это peer-to-peer обучение. В образовательном процессе нет менторов и экспертов, перед которыми ты защищаешь свой результат. Ты это делаешь перед таким же учащимися, как и ты сам. У них есть чек-лист, который поможет им качественно выполнить приемку вашей работы.

Роль Школы 21 заключается в том, чтобы обеспечить через последовательность заданий и оптимальный уровень поддержки такую траекторию обучения, при которой ты не только освоишь hard skills, но и научишься самообучаться.

- Не доверяй слухам и предположениям о том, как должно быть оформлено ваше решение. Этот документ является единственным источником, к которому стоит обращаться по большинству вопросов;
- твое решение будет оцениваться другими учащимися;
- подлежат оцениванию только те файлы, которые ты выложил в GIT (ветка develop, папка src);
- в твоей папке не должно быть лишних файлов — только те, что были указаны в задании;
- не забывай, что у вас есть доступ к интернету и поисковым системам;
- обсуждение заданий можно вести и в Slack;
- будь внимателен к примерам, указанным в этом документе — они могут иметь важные детали, которые не были оговорены другим способом;
- и да пребудет с тобой Сила!


<h3 id="задание">Задание</h3>

Для работы с SQL и тренировки будем пользоваться sqliteonline.com
По ссылке ты откроешь инструмент SQL Lite Online - онлайн-песочница, к которой, как мы делали ранее с Yandex DataLens, можно подключить свои файлы в качестве источника данных и потренироваться в написании запросов на языке SQL. Для загрузки своего файла нажми кнопку Import и загрузи файл. Слева отображается структура нашей базы данных: какие есть таблицы, какие столбцы в ней содержатся, данные каких типов хранятся в столбцах. Также в тренажере есть подсказки по использованию команд, и в самом скрипте будут удобно подсвечиваться ключевые слова.


1. Загрузи в [sqliteonline.com](https://sqliteonline.com/) файлы da_project05_purch.csv и da_project05_events.csv из папки datasets к этому проекту. В файле da_project05_purch.csv, как и ранее, хранится информация о покупках в интернет-магазине, в файле da_project05_events.csv - о просмотрах страниц и переходах в корзину. При импорте выбери ”First line” в поле Column name, чтобы первая строка датасета распозналась, как названия столбцов (как делали ранее в DataLens). 

2. Так как все события, включая платежи, пишутся в потоке, в таблицах хранятся одинаковые столбцы, мы можем объединить их с использованием команды UNION ALL и получить всю последовательность действий наших пользователей. Используя объединение в качестве подзапроса, вычисли, сколько строк хранится в обоих таблицах всего.

3. Переиспользуй подзапрос с объединением из прошлого задания и вычисли количество уникальных пользователей на сайте по месяцам. Этот показатель называется MAU - Monthly Active Users — количество уникальных пользователей в приложении или онлайн-сервисе за месяц без учета повторных сессий.

4. Так как не все пользователи обладают одинаковой информативностью, мы можем через пересечение таблиц поработать с теми, кто совершал покупки. Для этого необходимо пересечеть таблицу со всеми действиями и таблицу с покупками по ключам. Обрати внимание, что кроме ID клиента есть еще ID сессии - сеанс пользовательской активности на сайте. Когда пользователь выходит из личного кабинета или долго не совершает никаких действий, текущая сессия считается завершенной и при следующем заходе начнется новая. В качестве параметров используй user_id и user_session. Т.к. не все из пользователей могли совершать покупки (как мы выяснили в п.2), лучше использовать FULL JOIN, иначе часть данных потеряется.

5. Вычисли, сколько строк получилось в объединенной таблице.

6. Далее посмотрим, сколько уникальных пользователей ушли с сайта не совершив покупку. В нашем случае это означает, что их нет в таблице платежей. Используя в условии table_purch.user_id is null, вычисли количество уникальных пользователей из table_events (1113)

7. Вычислим, сколько раз в среднем покупателю нужно посмотреть карточку товара, чтобы его купить. В качестве условий для пересечения таблиц кроме user_id используй product_id - ID карточки товара. Так как пользователю не обязательно оплачивать товар в ту же сессию (он может сегодня посмотреть, а купить через неделю), условие по user_session мы не используем. Для пересечения используй команду LEFT JOIN, чтобы в итоговой таблице были только пользователи, совершившие покупки. Столбец event_time из таблицы платежей будет соответствовать времени оплаты, а event_time из таблицы просмотров - время совершения события. Считаем, что после одной покупки пользователь товаром больше не интересуется, поэтому используем условие table_purch.event_time >= table_events.event_time - просмотр карточки был до покупки. В итоговой таблице оставляем только b.event_type = 'view'. Далее необходимо посчитать, сколько пользователь совершил действий, и усреднить этот параметр по всем при помощи функции avg(). Этот параметр дает нам понять, сколько в среднем кликов на сайте должен сделать пользователь, чтобы купить интересующий его товар. 

8. Переиспользуй запрос из п.7, добавив в него в группировку категорию товара и вычисли, сколько кликов нужно для покупки товаров из всех подкатегорий 'computers.', для поиска можно использовать конструкцию LIKE '%computers%', как мы делали ранее.

Сверьте результаты в команде и соберите в общий .txt файл ответы на следующие вопросы:

   1. сколько строк получилось при объединении двух таблиц через UNION ALL
   2. сколько составил показатель MAU в самый прибыльный месяц, январь 2021 года
   3. сколько строк получилось при пересечении двух таблиц через FULL JOIN 
   4. сколько уникальных пользователей ушли с сайта не совершив ни одной покупки за весь период
   5. сколько в среднем требуется просмотров для покупки товара в категории computers.components.videocards, запиши с точностью до двух знаков 
   6. какую подкатегорию из 'computers.' выбирают дольше всего (нужно больше всего просмотров) 


<h3 id="дополнительное-задание">*Дополнительное задание</h3>

Кроме знаний об активной месячной аудитории важно так же понимать, сколько из этих пользователей совершает покупки - **%PU** - paying users - пользователи, которые заплатили. В этом задании мы попробуем расчитать %PU для нашей аудитории.
При FULL JOIN двух таблиц (а в этом случае нам надо учитывать всех пользователей, поэтому FULL) у нас образуется 2 колонки month в которых есть пропуски, т.к. не все пользователи совершали покупки, и не все покупатели могли что-то делать на сайте до оплаты (например, если был собранный предзаказ и ссылка на оплату на почте), и 2 колонки user_id, в которых тоже есть пропуски. Для того, чтобы заполнить пропуски, часто используют функцию **coalesce()** - она возвращает первое ненулевое выражение из списка. Т.е. если использовать ее как **coalesce(a.user_id, b.user_id) as user** - она вернет для пользователя user_id из первой или из второй таблицы, в зависимости от того, где он присуствует (может и в обеих).
Далее попробуем расчитать %PU, основываясь на флагах, совершал пользователь покупку в этом месяце или нет. Алгоритм аналогичный бонусному заданию в проекте 6. Нумерацию действий можно использовать для ориентира по уровням подзапросов:
1. заполни пропуски в столбцах user_id и month
2. промаркирую пользователей флагами по совершению покупки. В данном случае, если пользователь есть в таблице платежей = 1, если нет = 0. Когда возьмем при группировке max() по этому признаку - получим однозначный флаг на каждого пользователя. Не забудь, что в группировке должен быть еще ммесяц.
3. для посчета общего количества пользователей можно воспользоваться функцией count(), а для подсчета количества покупателей используй sum() по признаку флага из п.2: суммируя все единички, ты как раз получишь количество пользователей, совершивших покупку в этом месяце.
4. выгрузи результаты: нажми на Export в верхнем меню и выбери CSV. В качестве разделителей укажи ';'
5. открой результаты в Excel и вычисли в отдельной колонке %PU - подели количество плательщиков на общее количество пользователей. 
6. добавь строкой 1 заголовки для таблицы: Month, Total, Payers, PU
7. построй линейную диаграмму для PU по месяцам и сохрани файл под названием da_project06_extra.xlsx 


<h2 id="chapter-iv">Chapter IV</h2> 
<h3 id="cдача-работы-и-проверка">Сдача работы и проверка</h3>

1. Впиши ответы на вопросы в файл блокнота с названием da_project07.txt 
2. При необходимости, оформи файл с дополнительным заданием da_project07_extra.xlsx 
4. Загрузи перечисленные выше файлы в GIT-репозиторий этого проекта для проверки (ветка develop, папка src).

💡 [Нажми здесь](https://forms.gle/ktDn2NzuGQWdBwv48) **чтобы отправить обратную связь по проекту**.
